/*
 * Tegra 18x SoC-specific mcerr code.
 *
 * Copyright (c) 2015, NVIDIA Corporation. All rights reserved.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */

#include <linux/platform/tegra/mcerr.h>
#include <dt-bindings/memory/tegra-swgroup.h>
#include <linux/interrupt.h>

/*** Auto generated by `mcp.pl'. Do not modify! ***/

struct mc_client mc_clients[] = {
	client("ptc", "csr_ptcr", INVALID),
	dummy_client,
	dummy_client,
	dummy_client,
	dummy_client,
	dummy_client,
	dummy_client,
	dummy_client,
	dummy_client,
	dummy_client,
	dummy_client,
	dummy_client,
	dummy_client,
	dummy_client,
	client("afi", "csr_afir", INVALID),
	dummy_client,
	dummy_client,
	dummy_client,
	dummy_client,
	dummy_client,
	dummy_client,
	client("hda", "csr_hdar", INVALID),
	client("hc", "csr_host1xdmar", INVALID),
	dummy_client,
	dummy_client,
	dummy_client,
	dummy_client,
	dummy_client,
	client("nvenc", "csr_nvencsrd", INVALID),
	dummy_client,
	dummy_client,
	client("sata", "csr_satar", INVALID),
	dummy_client,
	dummy_client,
	dummy_client,
	dummy_client,
	dummy_client,
	dummy_client,
	dummy_client,
	client("mpcore", "csr_mpcorer", INVALID),
	dummy_client,
	dummy_client,
	dummy_client,
	client("nvenc", "csw_nvencswr", INVALID),
	dummy_client,
	dummy_client,
	dummy_client,
	dummy_client,
	dummy_client,
	client("afi", "csw_afiw", INVALID),
	dummy_client,
	dummy_client,
	dummy_client,
	client("hda", "csw_hdaw", INVALID),
	dummy_client,
	dummy_client,
	dummy_client,
	client("mpcore", "csw_mpcorew", INVALID),
	dummy_client,
	dummy_client,
	dummy_client,
	client("sata", "csw_sataw", INVALID),
	dummy_client,
	dummy_client,
	dummy_client,
	dummy_client,
	dummy_client,
	dummy_client,
	client("isp2", "csr_ispra", INVALID),
	dummy_client,
	client("isp2", "csw_ispwa", INVALID),
	client("isp2", "csw_ispwb", INVALID),
	dummy_client,
	dummy_client,
	client("xusb_host", "csr_xusb_hostr", INVALID),
	client("xusb_host", "csw_xusb_hostw", INVALID),
	client("xusb_dev", "csr_xusb_devr", INVALID),
	client("xusb_dev", "csw_xusb_devw", INVALID),
	dummy_client,
	dummy_client,
	dummy_client,
	dummy_client,
	dummy_client,
	dummy_client,
	client("tsec", "csr_tsecsrd", INVALID),
	client("tsec", "csw_tsecswr", INVALID),
	dummy_client,
	dummy_client,
	client("gpu", "csr_gpusrd", INVALID),
	client("gpu", "csw_gpuswr", INVALID),
	dummy_client,
	dummy_client,
	dummy_client,
	dummy_client,
	dummy_client,
	dummy_client,
	client("sdmmc1a", "csr_sdmmcra", INVALID),
	client("sdmmc2a", "csr_sdmmcraa", INVALID),
	client("sdmmc3a", "csr_sdmmcr", INVALID),
	client("sdmmc4a", "csr_sdmmcrab", INVALID),
	client("sdmmc1a", "csw_sdmmcwa", INVALID),
	client("sdmmc2a", "csw_sdmmcwaa", INVALID),
	client("sdmmc3a", "csw_sdmmcw", INVALID),
	client("sdmmc4a", "csw_sdmmcwab", INVALID),
	dummy_client,
	dummy_client,
	dummy_client,
	dummy_client,
	client("vic", "csr_vicsrd", INVALID),
	client("vic", "csw_vicswr", INVALID),
	dummy_client,
	dummy_client,
	dummy_client,
	dummy_client,
	client("vi", "csw_viw", INVALID),
	dummy_client,
	dummy_client,
	dummy_client,
	dummy_client,
	dummy_client,
	client("nvdec", "csr_nvdecsrd", INVALID),
	client("nvdec", "csw_nvdecswr", INVALID),
	client("ape", "csr_aper", INVALID),
	client("ape", "csw_apew", INVALID),
	dummy_client,
	dummy_client,
	client("nvjpg", "csr_nvjpgsrd", INVALID),
	client("nvjpg", "csw_nvjpgswr", INVALID),
	client("se", "csr_sesrd", INVALID),
	client("se", "csw_seswr", INVALID),
	dummy_client,
	dummy_client,
	client("etr", "csr_etrr", INVALID),
	client("etr", "csw_etrw", INVALID),
	client("tsecb", "csr_tsecsrdb", INVALID),
	client("tsecb", "csw_tsecswrb", INVALID),
	client("gpu", "csr_gpusrd2", INVALID),
	client("gpu", "csw_gpuswr2", INVALID),
	dummy_client,
	dummy_client,
	client("axis", "csr_axisr", INVALID),
	client("axis", "csw_axisw", INVALID),
	client("eqos", "csr_eqosr", INVALID),
	client("eqos", "csw_eqosw", INVALID),
	client("ufshc", "csr_ufshcr", INVALID),
	client("ufshc", "csw_ufshcw", INVALID),
	client("nvdisplay", "csr_nvdisplayr", INVALID),
	client("bpmp", "csr_bpmpr", INVALID),
	client("bpmp", "csw_bpmpw", INVALID),
	client("bpmp", "csr_bpmpdmar", INVALID),
	client("bpmp", "csw_bpmpdmaw", INVALID),
	client("aon", "csr_aonr", INVALID),
	client("aon", "csw_aonw", INVALID),
	client("aon", "csr_aondmar", INVALID),
	client("aon", "csw_aondmaw", INVALID),
	client("sce", "csr_scer", INVALID),
	client("sce", "csw_scew", INVALID),
	client("sce", "csr_scedmar", INVALID),
	client("sce", "csw_scedmaw", INVALID),
	client("ape", "csr_apedmar", INVALID),
	client("ape", "csw_apedmaw", INVALID),
	client("nvdisplay", "csr_nvdisplayr1", INVALID),
	client("vic", "csr_vicsrd1", INVALID),
	client("nvdec", "csr_nvdecsrd1", INVALID),
};
int mc_client_last = ARRAY_SIZE(mc_clients) - 1;
/*** Done. ***/

static const char *t186_intr_info[] = {
	NULL,		/* Bit 0 */
	NULL,
	NULL,
	NULL,
	NULL,		/* Bit 4 */
	NULL,
	"decerr-emem",
	NULL,
	"secerr",	/* Bit 8 */
	"arb-emem",
	"smmu-err",
	"apb_err",
	"decerr-vpr",	/* Bit 12 */
	"decerr-sec",
	NULL,
	NULL,
	"decerr-mts",	/* Bit 16 */
	"decerr-gsc",
	"scrub-ecc",
	"wcam-err",
	NULL,		/* Bit 20 */
	NULL,
	NULL,
	NULL,
	NULL,		/* Bit 24 */
	NULL,
	NULL,
	NULL,
	NULL,		/* Bit 28 */
	NULL,
	NULL,
	NULL,
};

enum {
	INTSTATUS_CH0 = 0,
	INTSTATUS_CH1 = 1,
	INTSTATUS_CH2 = 2,
	INTSTATUS_CH3 = 3,
	INTSTATUS_HUB0 = 16,
	INTSTATUS_HUB1 = 17,
	INTSTATUS_BROADCAST = 24,
};

irqreturn_t tegra_mc_error_hard_irq_ovr(int irq, void *data)
{
	u32 local_intstatus;
	u32 g_intstatus = mc_readl(MC_GLOBAL_INTSTATUS);

	trace_printk("MCERR detected.\n");

	/*
	 * If multiple interrupts come in just handle the first one we see. The
	 * HW only keeps track of 1 interrupt's data and we don't know which
	 * particular fault is actually being kept...
	 */
	if (g_intstatus & (1 << INTSTATUS_CH0) ||
	    g_intstatus & (1 << INTSTATUS_HUB0)) {
		mc_err_channel = 0;
	} else if (g_intstatus & (1 << INTSTATUS_CH1) ||
		   g_intstatus & (1 << INTSTATUS_HUB1)) {
		mc_err_channel = 1;
	} else if (g_intstatus & (1 << INTSTATUS_CH2)) {
		mc_err_channel = 2;
	} else if (g_intstatus & (1 << INTSTATUS_CH3)) {
		mc_err_channel = 3;
	} else if (g_intstatus & (1 << INTSTATUS_BROADCAST)) {
		mc_err_channel = MC_BROADCAST_CHANNEL;
	} else {
		trace_printk("mcerr: unknown source (intstatus = 0x%08x)\n",
			     g_intstatus);
		return IRQ_NONE;
	}

	/* prevent new interrupts unti we've handled this one */
	mc_writel(0, MC_INTMASK);
	mc_readl(MC_INTMASK);

	/* clear the current interrupt to prevent it firing again */
	local_intstatus = __mc_readl(mc_err_channel, MC_INTSTATUS);
	__mc_writel(mc_err_channel, local_intstatus, MC_INTSTATUS);

	mc_writel(g_intstatus, MC_GLOBAL_INTSTATUS);

	return IRQ_WAKE_THREAD;
}

void mcerr_chip_specific_setup(struct mcerr_chip_specific *spec)
{
	spec->nr_clients = ARRAY_SIZE(mc_clients);
	spec->intr_descriptions = t186_intr_info;
	return;
}
